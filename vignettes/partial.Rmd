---
title: "Partial"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Validation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
options(rmarkdown.html_vignette.check_title = FALSE)
library(tidyverse)
```

# Introduction

The `ped2com` function can be used to calculate the components of the genetic relationship matrix. The function has two methods to handle the parent adjacency matrix. The first method is the classic method, which is the default method in the function. The second method is the partial parent method. The partial parent method is more accurate when there are missing values in the parent adjacency matrix. This vignette will show the difference between the two methods when there are missing values in the parent adjacency matrix.


### Hazzard data
#### Drop mom of individual 4

```{r}
library(BGmisc)

data(hazard)

df <- hazard # this is the data that we will use for the example

# LOOK AT THAT UNUNUAL DYADS

## SISTER WIVES 


ped_add_partial_complete <- ped2com(df, isChild_method= "partialparent",
                                  component = "additive",
                                  adjacency_method = "direct")
ped_add_classic_complete <- ped2com(df, isChild_method= "classic",
                                  component = "additive", adjacency_method = "direct")

write.csv(ped_add_partial_complete, "ped_add_partial_complete.csv")
write.csv(ped_add_classic_complete, "ped_add_classic_complete.csv")
```


These first two additive matrices show what happens in both methods when you have intact family trees. The two matrices should be the same.

```{r}

library(ggcorrplot)
library(corrplot)

if(FALSE){
ggcorrplot(ped_add_partial_complete, hc.order = TRUE, 
           lab = TRUE, lab_size = 3, method = "square", outline.col = "white", digits = 3,
           title = "Additive component - Partial parent method")
  
}

corrplot(as.matrix(ped_add_classic_complete),
         method = 'color', type = 'lower', col.lim = c(0,1),
         is.corr = FALSE, title = "Additive component - Classic method")

corrplot(as.matrix(ped_add_partial_complete),
         method = 'color', type = 'lower', col.lim = c(0,1),
         is.corr = FALSE, title = "Additive component - Partial parent method")

```

First, we will compare the results of the two methods for the additive component. We will use the direct adjacency method. The first method is the classic method, which is the default method in the function. The second method is the partial parent method. These should behave the same when there are no missing values. 


Indeed when we subtract one matrix from the other , we can see that they are the same. And we note that the RMSE is `r sqrt(mean((ped_add_classic_complete-ped_add_partial_complete)^2))`.

```{r}

corrplot(as.matrix(ped_add_classic_complete-ped_add_partial_complete),
         method = 'color', type = 'lower', col.lim = c(0,1),
         is.corr = FALSE)


```


However, when there are missing values, the partial parent method should be more accurate. For this example, we will remove the mother of individual 4. We will then compare the results of the two methods. The key comparisons are how each method performs relative to the "true" additive component. The true additive component is the additive component calculated without any missing data. And how they compare to each other.


#### Drop Mom

```{r}

  df$momID[df$ID == 4] <- NA
  # add
ped_add_partial_mom <- ped_add_partial<- ped2com(df, isChild_method= "partialparent",
                             component = "additive",
                             adjacency_method = "direct")
  
ped_add_classic_mom <-  ped_add_classic <- ped2com(df, isChild_method= "classic",
                             component = "additive", adjacency_method = "direct")

```


As we can see, the two matrices are different. The RMSE between the two matrices is `r sqrt(mean((ped_add_classic-ped_add_partial)^2))`.

This plot shows the relatedness matrix when we use the classic method.

```{r}
corrplot(as.matrix(ped_add_classic),
         method = 'color', type = 'lower', col.lim = c(0,1),
         is.corr = FALSE)
```


This plot shows the relatedness matrix when we use the partial parent method.


```{r}
corrplot(as.matrix(ped_add_partial),
         method = 'color', type = 'lower', col.lim = c(0,1),
         is.corr = FALSE)
```




When we compare these methods to the true additive component, we can see that the partial parent method is more accurate. The RMSE between the true additive component and the classic method is `r sqrt(mean((ped_add_classic_complete-ped_add_classic)^2))`. The RMSE between the true additive component and the partial parent method is `r  sqrt(mean((ped_add_classic_complete-ped_add_partial)^2))`. And the RMSE between the classic method and the partial parent method is `r sqrt(mean((ped_add_classic-ped_add_partial)^2))`.

```{r}

#true_diff <- as.matrix(ped_add_classic_complete-ped_add_partial)

# filter rows that aren't impacted a.k.a. rows that are all 0 or columns that are all 0

#true_diff_thin <- as.data.frame(ped_add_classic_complete-ped_add_partial) %>% mutate(row = #row_number()) %>% 
#  filter(row %in% which(rowSums(ped_add_classic_complete-ped_add_partial)!=0))

#true_diff_thin %>% as.data.frame()%>%
  # columns that sum to 0 so that we can remove them 
#  mutate(col = colSums(true_diff_thin)==1)
#
#%>%
#  filter(col != 0) %>% select(-col, -row) %>% as.matrix()

# key comparison isn't versus truth. it's versus the alterative solution

# think about this more mason. these comparisons are important
```



The classic adjustment compared to the true additive component is shown below. 

```{r}
corrplot(as.matrix(ped_add_classic_complete-ped_add_classic),
         method = 'color', type = 'lower', col.lim = c(0,1),
         is.corr = FALSE)

sqrt(mean((ped_add_classic_complete-ped_add_classic)^2))

```


The partial parent adjustment compared to the true additive component is shown below.


```{r}
corrplot(as.matrix(ped_add_classic_complete-ped_add_partial),
         method = 'color', type = 'lower', col.lim = c(0,1),
         is.corr = FALSE)

sqrt(mean((ped_add_classic_complete-ped_add_partial)^2))

```



The classic adjustment compared to the partial parent adjustment is shown below.

```{r}
corrplot(as.matrix(ped_add_partial-ped_add_classic),
         method = 'color', type = 'lower', col.lim = c(0,1),
         is.corr = FALSE)

sqrt(mean((ped_add_partial-ped_add_classic)^2))
       
```

#### Drop dad of individual 4

```{r}


data(hazard)

df <- hazard # this is the data that we will use for the example

```



What happens if we drop the dad of individual 4?

```{r}

  df$dadID[df$ID == 4] <- NA
  # add
ped_add_partial_dad <- ped_add_partial<- ped2com(df, isChild_method= "partialparent",
                             component = "additive",
                             adjacency_method = "direct")
  
ped_add_classic_dad <-  ped_add_classic <- ped2com(df, isChild_method= "classic",
                             component = "additive", adjacency_method = "direct")

```


As we can see, the two matrices are different. The RMSE between the two matrices is `r sqrt(mean((ped_add_classic-ped_add_partial)^2))`.

This plot shows the relatedness matrix when we use the classic method.

```{r}
corrplot(as.matrix(ped_add_classic),
         method = 'color', type = 'lower', col.lim = c(0,1),
         is.corr = FALSE)
```


This plot shows the relatedness matrix when we use the partial parent method.


```{r}
corrplot(as.matrix(ped_add_partial),
         method = 'color', type = 'lower', col.lim = c(0,1),
         is.corr = FALSE)
```




When we compare these methods to the true additive component, we can see that the partial parent method is more accurate. The RMSE between the true additive component and the classic method is `r sqrt(mean((ped_add_classic_complete-ped_add_classic)^2))`. The RMSE between the true additive component and the partial parent method is `r  sqrt(mean((ped_add_classic_complete-ped_add_partial)^2))`. And the RMSE between the classic method and the partial parent method is `r sqrt(mean((ped_add_classic-ped_add_partial)^2))`.


The classic adjustment compared to the true additive component is shown below. 

```{r}
corrplot(as.matrix(ped_add_classic_complete-ped_add_classic),
         method = 'color', type = 'lower', col.lim = c(0,1),
         is.corr = FALSE)

sqrt(mean((ped_add_classic_complete-ped_add_classic)^2))

```


The partial parent adjustment compared to the true additive component is shown below.


```{r}
corrplot(as.matrix(ped_add_classic_complete-ped_add_partial),
         method = 'color', type = 'lower', col.lim = c(0,1),
         is.corr = FALSE)

sqrt(mean((ped_add_classic_complete-ped_add_partial)^2))

```



The classic adjustment compared to the partial parent adjustment is shown below.

```{r}
corrplot(as.matrix(ped_add_partial-ped_add_classic),
         method = 'color', type = 'lower', col.lim = c(0,1),
         is.corr = FALSE)

sqrt(mean((ped_add_partial-ped_add_classic)^2))
       
```

## Inbreeding

```{r}

data("inbreeding")

df <- inbreeding

FamIDs <- unique(df$FamID)

inbreeding_list <- list()
results <- data.frame(FamIDs = FamIDs,
                      RMSE_partial_dad = rep(NA, length(FamIDs)),
                      RMSE_partial_mom = rep(NA, length(FamIDs)),
                      RMSE_classic_dad = rep(NA, length(FamIDs)),
                      RMSE_classic_mom = rep(NA, length(FamIDs)),
                      max_R_classic_dad = rep(NA, length(FamIDs)),
                      max_R_partial_dad = rep(NA, length(FamIDs)),
                      max_R_classic_mom = rep(NA, length(FamIDs)),
                      max_R_partial_mom = rep(NA, length(FamIDs)),
                      max_R_classic = rep(NA, length(FamIDs)))
for (i in 1:length(FamIDs)) {
  
# make three versions to filter down
df_fam_dad<-df_fam_mom <- df_fam <- df[df$FamID == FamIDs[i],]
  
results$RMSE_partial_mom[i] <- sqrt(mean((ped_add_classic_complete-ped_add_partial_mom)^2))

  
ped_add_partial_complete <- ped2com(df_fam, isChild_method= "partialparent",
                                  component = "additive",
                                  adjacency_method = "direct")

ped_add_classic_complete <- ped2com(df_fam, isChild_method= "classic",
                                  component = "additive",
                                  adjacency_method = "direct")


# select first ID with a mom and dad
momid_to_cut <- df_fam$ID[!is.na(df_fam$momID)] %>% head(1)
dadid_to_cut <- df_fam$ID[!is.na(df_fam$dadID)] %>% head(1)

df_fam_dad$dadID[df_fam$ID == dadid_to_cut] <- NA

df_fam_mom$momID[df_fam$ID == momid_to_cut] <- NA

ped_add_partial_dad <- ped2com(df_fam_dad, isChild_method= "partialparent",
                             component = "additive",
                             adjacency_method = "direct")
ped_add_classic_dad <- ped2com(df_fam_dad, isChild_method= "classic",
                             component = "additive", adjacency_method = "direct")

results$RMSE_partial_dad[i] <- sqrt(mean((ped_add_classic_complete-ped_add_partial_dad)^2))
results$RMSE_classic_dad[i] <- sqrt(mean((ped_add_classic_complete-ped_add_classic_dad)^2))
results$max_R_classic_dad[i] <-  max(as.matrix(ped_add_classic_dad))
results$max_R_partial_dad[i] <-  max(as.matrix(ped_add_partial_dad))


ped_add_partial_mom <- ped2com(df_fam_mom, isChild_method= "partialparent",
                             component = "additive",
                             adjacency_method = "direct")

ped_add_classic_mom <-  ped2com(df_fam_mom, isChild_method= "classic",
                             component = "additive", adjacency_method = "direct")

results$RMSE_partial_mom[i] <- sqrt(mean((ped_add_classic_complete-ped_add_partial_mom)^2))
results$RMSE_classic_mom[i] <- sqrt(mean((ped_add_classic_complete-ped_add_classic_mom)^2))
results$max_R_classic_mom[i] <-  max(as.matrix(ped_add_classic_mom))
results$max_R_partial_mom[i] <-  max(as.matrix(ped_add_partial_mom))
results$max_R_classic[i] <-  max(as.matrix(ped_add_classic_complete))

inbreeding_list[[i]] <- list(df_fam=df_fam,
                            ped_add_partial_complete = ped_add_partial_complete,
                             ped_add_classic_complete = ped_add_classic_complete,
                             ped_add_partial_dad = ped_add_partial_dad,
                             ped_add_classic_dad = ped_add_classic_dad,
                             ped_add_partial_mom = ped_add_partial_mom,
                             ped_add_classic_mom = ped_add_classic_mom)

}

write.csv(results, "results.csv")
```

## Summary

```{r}

results <- results %>% as.data.frame() %>% mutate(RMSE_diff_dad = RMSE_classic_dad - RMSE_partial_dad,
                                                   RMSE_diff_mom = RMSE_classic_mom - RMSE_partial_mom)

results 

results %>% as.data.frame() %>% select(-FamIDs) %>% summary()
```


The partial parent method is more accurate when there are missing values in the parent adjacency matrix. 

<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>Validating and Repairing Pedigree Data with BGmisc</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Validating and Repairing Pedigree Data with
BGmisc</h1>



<div id="introduction" class="section level1">
<h1>Introduction</h1>
<p>Working with pedigree data often involves dealing with
inconsistencies, missing information, and errors. The
<code>BGmisc</code> package provides tools to identify and, where
possible, repair these issues automatically. This vignette demonstrates
how to validate and clean pedigree data using <code>BGmisc</code>’s
validation functions.</p>
</div>
<div id="identifying-and-repairing-id-issues" class="section level1">
<h1>Identifying and Repairing ID Issues</h1>
<p>The <code>checkIDs()</code> function detects two types of ID
duplication:</p>
<ul>
<li>Between-row duplication: When two or more individuals share the same
ID</li>
<li>Within-row duplication: When an individual’s parents’ IDs are
incorrectly listed as their own ID</li>
</ul>
<p>To illustrate <code>checkIDs()</code> in action, we will examine a
clean example using the Potter family dataset.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="fu">library</span>(BGmisc)</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="co"># Load our example dataset</span></span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a>df <span class="ot">&lt;-</span> <span class="fu">ped2fam</span>(potter, <span class="at">famID =</span> <span class="st">&quot;newFamID&quot;</span>, <span class="at">personID =</span> <span class="st">&quot;personID&quot;</span>)</span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a><span class="co"># Check for ID issues</span></span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a>result <span class="ot">&lt;-</span> <span class="fu">checkIDs</span>(df, <span class="at">repair =</span> <span class="cn">FALSE</span>)</span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a><span class="fu">print</span>(result)</span>
<span id="cb1-9"><a href="#cb1-9" tabindex="-1"></a><span class="co">#&gt; $all_unique_ids</span></span>
<span id="cb1-10"><a href="#cb1-10" tabindex="-1"></a><span class="co">#&gt; [1] TRUE</span></span>
<span id="cb1-11"><a href="#cb1-11" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb1-12"><a href="#cb1-12" tabindex="-1"></a><span class="co">#&gt; $total_non_unique_ids</span></span>
<span id="cb1-13"><a href="#cb1-13" tabindex="-1"></a><span class="co">#&gt; [1] 0</span></span>
<span id="cb1-14"><a href="#cb1-14" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb1-15"><a href="#cb1-15" tabindex="-1"></a><span class="co">#&gt; $total_own_father</span></span>
<span id="cb1-16"><a href="#cb1-16" tabindex="-1"></a><span class="co">#&gt; [1] 0</span></span>
<span id="cb1-17"><a href="#cb1-17" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb1-18"><a href="#cb1-18" tabindex="-1"></a><span class="co">#&gt; $total_own_mother</span></span>
<span id="cb1-19"><a href="#cb1-19" tabindex="-1"></a><span class="co">#&gt; [1] 0</span></span>
<span id="cb1-20"><a href="#cb1-20" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb1-21"><a href="#cb1-21" tabindex="-1"></a><span class="co">#&gt; $total_duplicated_parents</span></span>
<span id="cb1-22"><a href="#cb1-22" tabindex="-1"></a><span class="co">#&gt; [1] 0</span></span>
<span id="cb1-23"><a href="#cb1-23" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb1-24"><a href="#cb1-24" tabindex="-1"></a><span class="co">#&gt; $total_within_row_duplicates</span></span>
<span id="cb1-25"><a href="#cb1-25" tabindex="-1"></a><span class="co">#&gt; [1] 0</span></span>
<span id="cb1-26"><a href="#cb1-26" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb1-27"><a href="#cb1-27" tabindex="-1"></a><span class="co">#&gt; $within_row_duplicates</span></span>
<span id="cb1-28"><a href="#cb1-28" tabindex="-1"></a><span class="co">#&gt; [1] FALSE</span></span></code></pre></div>
<p>The checkIDs() function checks for:</p>
<ul>
<li>Whether all IDs are unique (reported by <code>all_unique_ids</code>,
which tells you if all IDs in the dataset are unique, and
<code>total_non_unique_ids</code>, which gives you the count of
non-unique IDs found)</li>
<li>Cases where someone’s ID matches their parent’s ID (shown in
<code>total_own_father</code> and <code>total_own_mother</code>, which
count individuals whose father’s or mother’s ID matches their own
ID)</li>
<li>Total duplicated parent IDs (tracked by
<code>total_duplicated_parents</code>, which counts individuals with
duplicated parent IDs)</li>
<li>Within-row duplicates (measured by
<code>total_within_row_duplicates</code> showing the count and
<code>within_row_duplicates</code> indicating their presence)</li>
</ul>
<p>As the output shows, there are no duplicates in our sample
dataset.</p>
<div id="a-tale-of-two-duplicates" class="section level2">
<h2>A Tale of Two Duplicates</h2>
<p>To understand how these tools work in practice, let’s create a
dataset with two common real-world problems. First, we’ll accidentally
give Vernon Dursley the same ID as his sister Marjorie (a common issue
when merging family records). Then, we’ll add a complete duplicate of
Dudley Dursley (as might happen during data entry).</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a></span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a><span class="co"># Create our problematic dataset</span></span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a>df_duplicates <span class="ot">&lt;-</span> df</span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a><span class="co"># Sibling ID conflict</span></span>
<span id="cb2-5"><a href="#cb2-5" tabindex="-1"></a>df_duplicates<span class="sc">$</span>personID[df_duplicates<span class="sc">$</span>name <span class="sc">==</span> <span class="st">&quot;Vernon Dursley&quot;</span>] <span class="ot">&lt;-</span> </span>
<span id="cb2-6"><a href="#cb2-6" tabindex="-1"></a>  df_duplicates<span class="sc">$</span>personID[df_duplicates<span class="sc">$</span>name <span class="sc">==</span> <span class="st">&quot;Marjorie Dursley&quot;</span>]</span>
<span id="cb2-7"><a href="#cb2-7" tabindex="-1"></a><span class="co"># Duplicate entry</span></span>
<span id="cb2-8"><a href="#cb2-8" tabindex="-1"></a>df_duplicates <span class="ot">&lt;-</span> <span class="fu">rbind</span>(df_duplicates, </span>
<span id="cb2-9"><a href="#cb2-9" tabindex="-1"></a>                       df_duplicates[df_duplicates<span class="sc">$</span>name <span class="sc">==</span> <span class="st">&quot;Dudley Dursley&quot;</span>, ])</span></code></pre></div>
<p>If we look at the data using standard tools, the problems aren’t
immediately obvious:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="fu">library</span>(tidyverse)</span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a><span class="fu">summarizeFamilies</span>(df_duplicates, </span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a>                  <span class="at">famID =</span> <span class="st">&quot;newFamID&quot;</span>, </span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a>                  <span class="at">personID =</span> <span class="st">&quot;personID&quot;</span>)<span class="sc">$</span>family_summary <span class="sc">%&gt;%</span> </span>
<span id="cb3-6"><a href="#cb3-6" tabindex="-1"></a>  <span class="fu">glimpse</span>()</span>
<span id="cb3-7"><a href="#cb3-7" tabindex="-1"></a><span class="co">#&gt; Rows: 1</span></span>
<span id="cb3-8"><a href="#cb3-8" tabindex="-1"></a><span class="co">#&gt; Columns: 17</span></span>
<span id="cb3-9"><a href="#cb3-9" tabindex="-1"></a><span class="co">#&gt; $ newFamID        &lt;dbl&gt; 1</span></span>
<span id="cb3-10"><a href="#cb3-10" tabindex="-1"></a><span class="co">#&gt; $ count           &lt;int&gt; 37</span></span>
<span id="cb3-11"><a href="#cb3-11" tabindex="-1"></a><span class="co">#&gt; $ gen_mean        &lt;dbl&gt; 1.756757</span></span>
<span id="cb3-12"><a href="#cb3-12" tabindex="-1"></a><span class="co">#&gt; $ gen_median      &lt;dbl&gt; 2</span></span>
<span id="cb3-13"><a href="#cb3-13" tabindex="-1"></a><span class="co">#&gt; $ gen_min         &lt;dbl&gt; 0</span></span>
<span id="cb3-14"><a href="#cb3-14" tabindex="-1"></a><span class="co">#&gt; $ gen_max         &lt;dbl&gt; 3</span></span>
<span id="cb3-15"><a href="#cb3-15" tabindex="-1"></a><span class="co">#&gt; $ gen_sd          &lt;dbl&gt; 1.038305</span></span>
<span id="cb3-16"><a href="#cb3-16" tabindex="-1"></a><span class="co">#&gt; $ spouseID_mean   &lt;dbl&gt; 38.2</span></span>
<span id="cb3-17"><a href="#cb3-17" tabindex="-1"></a><span class="co">#&gt; $ spouseID_median &lt;dbl&gt; 15</span></span>
<span id="cb3-18"><a href="#cb3-18" tabindex="-1"></a><span class="co">#&gt; $ spouseID_min    &lt;dbl&gt; 1</span></span>
<span id="cb3-19"><a href="#cb3-19" tabindex="-1"></a><span class="co">#&gt; $ spouseID_max    &lt;dbl&gt; 106</span></span>
<span id="cb3-20"><a href="#cb3-20" tabindex="-1"></a><span class="co">#&gt; $ spouseID_sd     &lt;dbl&gt; 44.15118</span></span>
<span id="cb3-21"><a href="#cb3-21" tabindex="-1"></a><span class="co">#&gt; $ sex_mean        &lt;dbl&gt; 0.5135135</span></span>
<span id="cb3-22"><a href="#cb3-22" tabindex="-1"></a><span class="co">#&gt; $ sex_median      &lt;dbl&gt; 1</span></span>
<span id="cb3-23"><a href="#cb3-23" tabindex="-1"></a><span class="co">#&gt; $ sex_min         &lt;dbl&gt; 0</span></span>
<span id="cb3-24"><a href="#cb3-24" tabindex="-1"></a><span class="co">#&gt; $ sex_max         &lt;dbl&gt; 1</span></span>
<span id="cb3-25"><a href="#cb3-25" tabindex="-1"></a><span class="co">#&gt; $ sex_sd          &lt;dbl&gt; 0.5067117</span></span></code></pre></div>
<p>This is where <code>checkIDs</code> becomes invaluable:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="co"># Identify duplicates</span></span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a>result <span class="ot">&lt;-</span> <span class="fu">checkIDs</span>(df_duplicates)</span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a><span class="fu">print</span>(result)</span>
<span id="cb4-4"><a href="#cb4-4" tabindex="-1"></a><span class="co">#&gt; $all_unique_ids</span></span>
<span id="cb4-5"><a href="#cb4-5" tabindex="-1"></a><span class="co">#&gt; [1] FALSE</span></span>
<span id="cb4-6"><a href="#cb4-6" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb4-7"><a href="#cb4-7" tabindex="-1"></a><span class="co">#&gt; $total_non_unique_ids</span></span>
<span id="cb4-8"><a href="#cb4-8" tabindex="-1"></a><span class="co">#&gt; [1] 4</span></span>
<span id="cb4-9"><a href="#cb4-9" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb4-10"><a href="#cb4-10" tabindex="-1"></a><span class="co">#&gt; $non_unique_ids</span></span>
<span id="cb4-11"><a href="#cb4-11" tabindex="-1"></a><span class="co">#&gt; [1] 2 6</span></span>
<span id="cb4-12"><a href="#cb4-12" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb4-13"><a href="#cb4-13" tabindex="-1"></a><span class="co">#&gt; $total_own_father</span></span>
<span id="cb4-14"><a href="#cb4-14" tabindex="-1"></a><span class="co">#&gt; [1] 0</span></span>
<span id="cb4-15"><a href="#cb4-15" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb4-16"><a href="#cb4-16" tabindex="-1"></a><span class="co">#&gt; $total_own_mother</span></span>
<span id="cb4-17"><a href="#cb4-17" tabindex="-1"></a><span class="co">#&gt; [1] 0</span></span>
<span id="cb4-18"><a href="#cb4-18" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb4-19"><a href="#cb4-19" tabindex="-1"></a><span class="co">#&gt; $total_duplicated_parents</span></span>
<span id="cb4-20"><a href="#cb4-20" tabindex="-1"></a><span class="co">#&gt; [1] 0</span></span>
<span id="cb4-21"><a href="#cb4-21" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb4-22"><a href="#cb4-22" tabindex="-1"></a><span class="co">#&gt; $total_within_row_duplicates</span></span>
<span id="cb4-23"><a href="#cb4-23" tabindex="-1"></a><span class="co">#&gt; [1] 0</span></span>
<span id="cb4-24"><a href="#cb4-24" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb4-25"><a href="#cb4-25" tabindex="-1"></a><span class="co">#&gt; $within_row_duplicates</span></span>
<span id="cb4-26"><a href="#cb4-26" tabindex="-1"></a><span class="co">#&gt; [1] FALSE</span></span></code></pre></div>
<p>As we can see from this output, there are 4 non-unique IDs in the
dataset, specifically 2, 6. Let’s take a peek at the duplicates:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="co"># Let&#39;s examine the problematic entries</span></span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a>df_duplicates <span class="sc">%&gt;%</span></span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a>  <span class="fu">filter</span>(personID <span class="sc">%in%</span> result<span class="sc">$</span>non_unique_ids) <span class="sc">%&gt;%</span></span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a>  <span class="fu">arrange</span>(personID)</span>
<span id="cb5-5"><a href="#cb5-5" tabindex="-1"></a><span class="co">#&gt;    personID newFamID famID             name gen momID dadID spouseID sex</span></span>
<span id="cb5-6"><a href="#cb5-6" tabindex="-1"></a><span class="co">#&gt; 1         2        1     1   Vernon Dursley   1   101   102        3   1</span></span>
<span id="cb5-7"><a href="#cb5-7" tabindex="-1"></a><span class="co">#&gt; 2         2        1     1 Marjorie Dursley   1   101   102       NA   0</span></span>
<span id="cb5-8"><a href="#cb5-8" tabindex="-1"></a><span class="co">#&gt; 6         6        1     1   Dudley Dursley   2     3     1       NA   1</span></span>
<span id="cb5-9"><a href="#cb5-9" tabindex="-1"></a><span class="co">#&gt; 61        6        1     1   Dudley Dursley   2     3     1       NA   1</span></span></code></pre></div>
<p>Yep, these are definitely the duplicates.</p>
<div id="repairing-between-row-duplicates" class="section level3">
<h3>Repairing Between-Row Duplicates</h3>
<p>Some ID issues can be fixed automatically. Let’s try the repair
option:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a>df_repair <span class="ot">&lt;-</span> <span class="fu">checkIDs</span>(df, <span class="at">repair =</span> <span class="cn">TRUE</span>)</span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a>df_repair <span class="sc">%&gt;%</span></span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a>  <span class="fu">filter</span>(ID <span class="sc">%in%</span> result<span class="sc">$</span>non_unique_ids) <span class="sc">%&gt;%</span></span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a>  <span class="fu">arrange</span>(ID)</span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a><span class="co">#&gt;   ID newFamID fam             name gen momID dadID spID sex</span></span>
<span id="cb6-7"><a href="#cb6-7" tabindex="-1"></a><span class="co">#&gt; 1  2        1   1 Marjorie Dursley   1   101   102   NA   0</span></span>
<span id="cb6-8"><a href="#cb6-8" tabindex="-1"></a><span class="co">#&gt; 2  6        1   1   Dudley Dursley   2     3     1   NA   1</span></span>
<span id="cb6-9"><a href="#cb6-9" tabindex="-1"></a></span>
<span id="cb6-10"><a href="#cb6-10" tabindex="-1"></a>result <span class="ot">&lt;-</span> <span class="fu">checkIDs</span>(df_repair)</span>
<span id="cb6-11"><a href="#cb6-11" tabindex="-1"></a></span>
<span id="cb6-12"><a href="#cb6-12" tabindex="-1"></a><span class="fu">print</span>(result)</span>
<span id="cb6-13"><a href="#cb6-13" tabindex="-1"></a><span class="co">#&gt; $all_unique_ids</span></span>
<span id="cb6-14"><a href="#cb6-14" tabindex="-1"></a><span class="co">#&gt; [1] TRUE</span></span>
<span id="cb6-15"><a href="#cb6-15" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb6-16"><a href="#cb6-16" tabindex="-1"></a><span class="co">#&gt; $total_non_unique_ids</span></span>
<span id="cb6-17"><a href="#cb6-17" tabindex="-1"></a><span class="co">#&gt; [1] 0</span></span>
<span id="cb6-18"><a href="#cb6-18" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb6-19"><a href="#cb6-19" tabindex="-1"></a><span class="co">#&gt; $total_own_father</span></span>
<span id="cb6-20"><a href="#cb6-20" tabindex="-1"></a><span class="co">#&gt; [1] 0</span></span>
<span id="cb6-21"><a href="#cb6-21" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb6-22"><a href="#cb6-22" tabindex="-1"></a><span class="co">#&gt; $total_own_mother</span></span>
<span id="cb6-23"><a href="#cb6-23" tabindex="-1"></a><span class="co">#&gt; [1] 0</span></span>
<span id="cb6-24"><a href="#cb6-24" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb6-25"><a href="#cb6-25" tabindex="-1"></a><span class="co">#&gt; $total_duplicated_parents</span></span>
<span id="cb6-26"><a href="#cb6-26" tabindex="-1"></a><span class="co">#&gt; [1] 0</span></span>
<span id="cb6-27"><a href="#cb6-27" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb6-28"><a href="#cb6-28" tabindex="-1"></a><span class="co">#&gt; $total_within_row_duplicates</span></span>
<span id="cb6-29"><a href="#cb6-29" tabindex="-1"></a><span class="co">#&gt; [1] 0</span></span>
<span id="cb6-30"><a href="#cb6-30" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb6-31"><a href="#cb6-31" tabindex="-1"></a><span class="co">#&gt; $within_row_duplicates</span></span>
<span id="cb6-32"><a href="#cb6-32" tabindex="-1"></a><span class="co">#&gt; [1] FALSE</span></span></code></pre></div>
<p>Great! Notice what happened here: the function was able to repair the
full duplicate, without any manual intervention. That still leaves us
with the sibling ID conflict, but that’s a more complex issue that would
require manual intervention. We’ll leave that for now.</p>
</div>
</div>
<div id="oedipus-id" class="section level2">
<h2>Oedipus ID</h2>
<p>Just as Oedipus discovered his true relationship was not what records
suggested, our data can reveal its own confused parentage when an ID is
incorrectly listed as its own parent. Let’s examine this error:</p>
<p>Sometimes, an individual’s parents’ IDs may be incorrectly listed as
their own ID, leading to within-row duplicates. The checkIDs function
can also identify these errors:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="co"># Create a sample dataset with within-person duplicate parent IDs</span></span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a>df_within <span class="ot">&lt;-</span> <span class="fu">ped2fam</span>(potter, <span class="at">famID =</span> <span class="st">&quot;newFamID&quot;</span>, <span class="at">personID =</span> <span class="st">&quot;personID&quot;</span>)</span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" tabindex="-1"></a>df_within<span class="sc">$</span>momID[df_within<span class="sc">$</span>name <span class="sc">==</span> <span class="st">&quot;Vernon Dursley&quot;</span>] <span class="ot">&lt;-</span> df_within<span class="sc">$</span>personID[df_within<span class="sc">$</span>name <span class="sc">==</span> <span class="st">&quot;Vernon Dursley&quot;</span>]</span>
<span id="cb7-6"><a href="#cb7-6" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" tabindex="-1"></a><span class="co"># Check for within-row duplicates</span></span>
<span id="cb7-8"><a href="#cb7-8" tabindex="-1"></a>result <span class="ot">&lt;-</span> <span class="fu">checkIDs</span>(df_within, <span class="at">repair =</span> <span class="cn">FALSE</span>)</span>
<span id="cb7-9"><a href="#cb7-9" tabindex="-1"></a><span class="fu">print</span>(result)</span>
<span id="cb7-10"><a href="#cb7-10" tabindex="-1"></a><span class="co">#&gt; $all_unique_ids</span></span>
<span id="cb7-11"><a href="#cb7-11" tabindex="-1"></a><span class="co">#&gt; [1] TRUE</span></span>
<span id="cb7-12"><a href="#cb7-12" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb7-13"><a href="#cb7-13" tabindex="-1"></a><span class="co">#&gt; $total_non_unique_ids</span></span>
<span id="cb7-14"><a href="#cb7-14" tabindex="-1"></a><span class="co">#&gt; [1] 0</span></span>
<span id="cb7-15"><a href="#cb7-15" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb7-16"><a href="#cb7-16" tabindex="-1"></a><span class="co">#&gt; $total_own_father</span></span>
<span id="cb7-17"><a href="#cb7-17" tabindex="-1"></a><span class="co">#&gt; [1] 0</span></span>
<span id="cb7-18"><a href="#cb7-18" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb7-19"><a href="#cb7-19" tabindex="-1"></a><span class="co">#&gt; $total_own_mother</span></span>
<span id="cb7-20"><a href="#cb7-20" tabindex="-1"></a><span class="co">#&gt; [1] 1</span></span>
<span id="cb7-21"><a href="#cb7-21" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb7-22"><a href="#cb7-22" tabindex="-1"></a><span class="co">#&gt; $total_duplicated_parents</span></span>
<span id="cb7-23"><a href="#cb7-23" tabindex="-1"></a><span class="co">#&gt; [1] 0</span></span>
<span id="cb7-24"><a href="#cb7-24" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb7-25"><a href="#cb7-25" tabindex="-1"></a><span class="co">#&gt; $total_within_row_duplicates</span></span>
<span id="cb7-26"><a href="#cb7-26" tabindex="-1"></a><span class="co">#&gt; [1] 1</span></span>
<span id="cb7-27"><a href="#cb7-27" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb7-28"><a href="#cb7-28" tabindex="-1"></a><span class="co">#&gt; $within_row_duplicates</span></span>
<span id="cb7-29"><a href="#cb7-29" tabindex="-1"></a><span class="co">#&gt; [1] TRUE</span></span>
<span id="cb7-30"><a href="#cb7-30" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb7-31"><a href="#cb7-31" tabindex="-1"></a><span class="co">#&gt; $is_own_mother_ids</span></span>
<span id="cb7-32"><a href="#cb7-32" tabindex="-1"></a><span class="co">#&gt; [1] 1</span></span></code></pre></div>
<p>In this example, we have created a within-row duplicate by setting
the momID of Vernon Dursley to his own ID. The <code>checkIDs</code>
function correctly identifies that this error is present.</p>
<p>To repair within-row duplicates, you will be able to set the repair
argument to <code>TRUE</code>, eventually. This feature is currently
under development and will be available in future versions of the
package. In the meantime, you can manually inspect and then correct
these errors in your dataset.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="co"># Find the problematic entry</span></span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a>df_within[df_within<span class="sc">$</span>momID <span class="sc">%in%</span> result<span class="sc">$</span>is_own_mother_ids, ]</span>
<span id="cb8-4"><a href="#cb8-4" tabindex="-1"></a><span class="co">#&gt;   personID newFamID famID           name gen momID dadID spouseID sex</span></span>
<span id="cb8-5"><a href="#cb8-5" tabindex="-1"></a><span class="co">#&gt; 1        1        1     1 Vernon Dursley   1     1   102        3   1</span></span></code></pre></div>
<p>There are several ways to correct this issue, depending on the
specifics of your dataset. In this case, you could correct the momID for
Vernon Dursley to the correct value, resolving the within-row duplicate,
likely by assuming that his sister Marjorie shares the same mother.</p>
</div>
</div>
<div id="identifying-and-repairing-sex-coding-issues" class="section level1">
<h1>Identifying and Repairing Sex Coding Issues</h1>
<p>Another critical aspect of pedigree validation is ensuring the
consistency of sex coding. This brings us to an important distinction in
genetic studies between biological sex (genotype) and gender identity
(phenotype):</p>
<ul>
<li>Biological sex (genotype) refers to an individual’s chromosomal
configuration, typically XX for female and XY for male in humans, though
variations exist.</li>
<li>Gender identity (phenotype) encompasses a broader, richer, personal,
deeply-held sense of being male, female, a blend of both, neither, or
another gender entirely.</li>
</ul>
<p>The <code>checkSex</code> function focuses on biological sex coding
consistency, particularly looking for: - Mismatches between parent roles
and recorded sex - Individuals listed as both parent and child -
Inconsistent sex coding across the dataset</p>
<p>Let’s examine how it works:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="co"># Validate sex coding</span></span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a>results <span class="ot">&lt;-</span> <span class="fu">checkSex</span>(potter,</span>
<span id="cb9-4"><a href="#cb9-4" tabindex="-1"></a>  <span class="at">code_male =</span> <span class="dv">1</span>,</span>
<span id="cb9-5"><a href="#cb9-5" tabindex="-1"></a>  <span class="at">code_female =</span> <span class="dv">0</span>,</span>
<span id="cb9-6"><a href="#cb9-6" tabindex="-1"></a>  <span class="at">verbose =</span> <span class="cn">TRUE</span>, <span class="at">repair =</span> <span class="cn">FALSE</span></span>
<span id="cb9-7"><a href="#cb9-7" tabindex="-1"></a>)</span>
<span id="cb9-8"><a href="#cb9-8" tabindex="-1"></a><span class="co">#&gt; Step 1: Checking how many sexes/genders...</span></span>
<span id="cb9-9"><a href="#cb9-9" tabindex="-1"></a><span class="co">#&gt; 2 unique values found.</span></span>
<span id="cb9-10"><a href="#cb9-10" tabindex="-1"></a><span class="co">#&gt;  1 2 unique values found.</span></span>
<span id="cb9-11"><a href="#cb9-11" tabindex="-1"></a><span class="co">#&gt;  0Checks Made:</span></span>
<span id="cb9-12"><a href="#cb9-12" tabindex="-1"></a><span class="co">#&gt; $sex_unique</span></span>
<span id="cb9-13"><a href="#cb9-13" tabindex="-1"></a><span class="co">#&gt; [1] 1 0</span></span>
<span id="cb9-14"><a href="#cb9-14" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb9-15"><a href="#cb9-15" tabindex="-1"></a><span class="co">#&gt; $sex_length</span></span>
<span id="cb9-16"><a href="#cb9-16" tabindex="-1"></a><span class="co">#&gt; [1] 2</span></span>
<span id="cb9-17"><a href="#cb9-17" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb9-18"><a href="#cb9-18" tabindex="-1"></a><span class="co">#&gt; $all_sex_dad</span></span>
<span id="cb9-19"><a href="#cb9-19" tabindex="-1"></a><span class="co">#&gt; [1] &quot;1&quot;</span></span>
<span id="cb9-20"><a href="#cb9-20" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb9-21"><a href="#cb9-21" tabindex="-1"></a><span class="co">#&gt; $all_sex_mom</span></span>
<span id="cb9-22"><a href="#cb9-22" tabindex="-1"></a><span class="co">#&gt; [1] &quot;0&quot;</span></span>
<span id="cb9-23"><a href="#cb9-23" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb9-24"><a href="#cb9-24" tabindex="-1"></a><span class="co">#&gt; $most_frequent_sex_dad</span></span>
<span id="cb9-25"><a href="#cb9-25" tabindex="-1"></a><span class="co">#&gt; [1] &quot;1&quot;</span></span>
<span id="cb9-26"><a href="#cb9-26" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb9-27"><a href="#cb9-27" tabindex="-1"></a><span class="co">#&gt; $most_frequent_sex_mom</span></span>
<span id="cb9-28"><a href="#cb9-28" tabindex="-1"></a><span class="co">#&gt; [1] &quot;0&quot;</span></span>
<span id="cb9-29"><a href="#cb9-29" tabindex="-1"></a><span class="fu">print</span>(results)</span>
<span id="cb9-30"><a href="#cb9-30" tabindex="-1"></a><span class="co">#&gt; $sex_unique</span></span>
<span id="cb9-31"><a href="#cb9-31" tabindex="-1"></a><span class="co">#&gt; [1] 1 0</span></span>
<span id="cb9-32"><a href="#cb9-32" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb9-33"><a href="#cb9-33" tabindex="-1"></a><span class="co">#&gt; $sex_length</span></span>
<span id="cb9-34"><a href="#cb9-34" tabindex="-1"></a><span class="co">#&gt; [1] 2</span></span>
<span id="cb9-35"><a href="#cb9-35" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb9-36"><a href="#cb9-36" tabindex="-1"></a><span class="co">#&gt; $all_sex_dad</span></span>
<span id="cb9-37"><a href="#cb9-37" tabindex="-1"></a><span class="co">#&gt; [1] &quot;1&quot;</span></span>
<span id="cb9-38"><a href="#cb9-38" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb9-39"><a href="#cb9-39" tabindex="-1"></a><span class="co">#&gt; $all_sex_mom</span></span>
<span id="cb9-40"><a href="#cb9-40" tabindex="-1"></a><span class="co">#&gt; [1] &quot;0&quot;</span></span>
<span id="cb9-41"><a href="#cb9-41" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb9-42"><a href="#cb9-42" tabindex="-1"></a><span class="co">#&gt; $most_frequent_sex_dad</span></span>
<span id="cb9-43"><a href="#cb9-43" tabindex="-1"></a><span class="co">#&gt; [1] &quot;1&quot;</span></span>
<span id="cb9-44"><a href="#cb9-44" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb9-45"><a href="#cb9-45" tabindex="-1"></a><span class="co">#&gt; $most_frequent_sex_mom</span></span>
<span id="cb9-46"><a href="#cb9-46" tabindex="-1"></a><span class="co">#&gt; [1] &quot;0&quot;</span></span></code></pre></div>
<p>When inconsistencies are found, you can attempt automatic repair:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a><span class="co"># Repair sex coding</span></span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a>df_fix <span class="ot">&lt;-</span> <span class="fu">checkSex</span>(potter,</span>
<span id="cb10-3"><a href="#cb10-3" tabindex="-1"></a>  <span class="at">code_male =</span> <span class="dv">1</span>,</span>
<span id="cb10-4"><a href="#cb10-4" tabindex="-1"></a>  <span class="at">code_female =</span> <span class="dv">0</span>,</span>
<span id="cb10-5"><a href="#cb10-5" tabindex="-1"></a>  <span class="at">verbose =</span> <span class="cn">TRUE</span>, <span class="at">repair =</span> <span class="cn">TRUE</span></span>
<span id="cb10-6"><a href="#cb10-6" tabindex="-1"></a>)</span>
<span id="cb10-7"><a href="#cb10-7" tabindex="-1"></a><span class="co">#&gt; Step 1: Checking how many sexes/genders...</span></span>
<span id="cb10-8"><a href="#cb10-8" tabindex="-1"></a><span class="co">#&gt; 2 unique values found.</span></span>
<span id="cb10-9"><a href="#cb10-9" tabindex="-1"></a><span class="co">#&gt;  1 2 unique values found.</span></span>
<span id="cb10-10"><a href="#cb10-10" tabindex="-1"></a><span class="co">#&gt;  0Step 2: Attempting to repair sex coding...</span></span>
<span id="cb10-11"><a href="#cb10-11" tabindex="-1"></a><span class="co">#&gt; Changes Made:</span></span>
<span id="cb10-12"><a href="#cb10-12" tabindex="-1"></a><span class="co">#&gt; [[1]]</span></span>
<span id="cb10-13"><a href="#cb10-13" tabindex="-1"></a><span class="co">#&gt; [1] &quot;Recode sex based on most frequent sex in dads: 1. Total gender changes made: 36&quot;</span></span>
<span id="cb10-14"><a href="#cb10-14" tabindex="-1"></a><span class="fu">print</span>(df_fix)</span>
<span id="cb10-15"><a href="#cb10-15" tabindex="-1"></a><span class="co">#&gt;     ID fam               name gen momID dadID spID sex</span></span>
<span id="cb10-16"><a href="#cb10-16" tabindex="-1"></a><span class="co">#&gt; 1    1   1     Vernon Dursley   1   101   102    3   M</span></span>
<span id="cb10-17"><a href="#cb10-17" tabindex="-1"></a><span class="co">#&gt; 2    2   1   Marjorie Dursley   1   101   102   NA   F</span></span>
<span id="cb10-18"><a href="#cb10-18" tabindex="-1"></a><span class="co">#&gt; 3    3   1      Petunia Evans   1   103   104    1   F</span></span>
<span id="cb10-19"><a href="#cb10-19" tabindex="-1"></a><span class="co">#&gt; 4    4   1         Lily Evans   1   103   104    5   F</span></span>
<span id="cb10-20"><a href="#cb10-20" tabindex="-1"></a><span class="co">#&gt; 5    5   1       James Potter   1    NA    NA    4   M</span></span>
<span id="cb10-21"><a href="#cb10-21" tabindex="-1"></a><span class="co">#&gt; 6    6   1     Dudley Dursley   2     3     1   NA   M</span></span>
<span id="cb10-22"><a href="#cb10-22" tabindex="-1"></a><span class="co">#&gt; 7    7   1       Harry Potter   2     4     5    8   M</span></span>
<span id="cb10-23"><a href="#cb10-23" tabindex="-1"></a><span class="co">#&gt; 8    8   1      Ginny Weasley   2    10     9    7   F</span></span>
<span id="cb10-24"><a href="#cb10-24" tabindex="-1"></a><span class="co">#&gt; 9    9   1     Arthur Weasley   1    NA    NA   10   M</span></span>
<span id="cb10-25"><a href="#cb10-25" tabindex="-1"></a><span class="co">#&gt; 10  10   1      Molly Prewett   1    NA    NA    9   F</span></span>
<span id="cb10-26"><a href="#cb10-26" tabindex="-1"></a><span class="co">#&gt; 11  11   1        Ron Weasley   2    10     9   17   M</span></span>
<span id="cb10-27"><a href="#cb10-27" tabindex="-1"></a><span class="co">#&gt; 12  12   1       Fred Weasley   2    10     9   NA   M</span></span>
<span id="cb10-28"><a href="#cb10-28" tabindex="-1"></a><span class="co">#&gt; 13  13   1     George Weasley   2    10     9   NA   M</span></span>
<span id="cb10-29"><a href="#cb10-29" tabindex="-1"></a><span class="co">#&gt; 14  14   1      Percy Weasley   2    10     9   20   M</span></span>
<span id="cb10-30"><a href="#cb10-30" tabindex="-1"></a><span class="co">#&gt; 15  15   1    Charlie Weasley   2    10     9   NA   M</span></span>
<span id="cb10-31"><a href="#cb10-31" tabindex="-1"></a><span class="co">#&gt; 16  16   1       Bill Weasley   2    10     9   18   M</span></span>
<span id="cb10-32"><a href="#cb10-32" tabindex="-1"></a><span class="co">#&gt; 17  17   1   Hermione Granger   2    NA    NA   11   F</span></span>
<span id="cb10-33"><a href="#cb10-33" tabindex="-1"></a><span class="co">#&gt; 18  18   1     Fleur Delacour   2   105   106   16   F</span></span>
<span id="cb10-34"><a href="#cb10-34" tabindex="-1"></a><span class="co">#&gt; 19  19   1 Gabrielle Delacour   2   105   106   NA   F</span></span>
<span id="cb10-35"><a href="#cb10-35" tabindex="-1"></a><span class="co">#&gt; 20  20   1     Audrey UNKNOWN   2    NA    NA   14   F</span></span>
<span id="cb10-36"><a href="#cb10-36" tabindex="-1"></a><span class="co">#&gt; 21  21   1    James Potter II   3     8     7   NA   M</span></span>
<span id="cb10-37"><a href="#cb10-37" tabindex="-1"></a><span class="co">#&gt; 22  22   1       Albus Potter   3     8     7   NA   M</span></span>
<span id="cb10-38"><a href="#cb10-38" tabindex="-1"></a><span class="co">#&gt; 23  23   1        Lily Potter   3     8     7   NA   F</span></span>
<span id="cb10-39"><a href="#cb10-39" tabindex="-1"></a><span class="co">#&gt; 24  24   1       Rose Weasley   3    17    11   NA   F</span></span>
<span id="cb10-40"><a href="#cb10-40" tabindex="-1"></a><span class="co">#&gt; 25  25   1       Hugo Weasley   3    17    11   NA   M</span></span>
<span id="cb10-41"><a href="#cb10-41" tabindex="-1"></a><span class="co">#&gt; 26  26   1   Victoire Weasley   3    18    16   NA   F</span></span>
<span id="cb10-42"><a href="#cb10-42" tabindex="-1"></a><span class="co">#&gt; 27  27   1  Dominique Weasley   3    18    16   NA   F</span></span>
<span id="cb10-43"><a href="#cb10-43" tabindex="-1"></a><span class="co">#&gt; 28  28   1      Louis Weasley   3    18    16   NA   M</span></span>
<span id="cb10-44"><a href="#cb10-44" tabindex="-1"></a><span class="co">#&gt; 29  29   1      Molly Weasley   3    20    14   NA   F</span></span>
<span id="cb10-45"><a href="#cb10-45" tabindex="-1"></a><span class="co">#&gt; 30  30   1       Lucy Weasley   3    20    14   NA   F</span></span>
<span id="cb10-46"><a href="#cb10-46" tabindex="-1"></a><span class="co">#&gt; 31 101   1     Mother Dursley   0    NA    NA  102   F</span></span>
<span id="cb10-47"><a href="#cb10-47" tabindex="-1"></a><span class="co">#&gt; 32 102   1     Father Dursley   0    NA    NA  101   M</span></span>
<span id="cb10-48"><a href="#cb10-48" tabindex="-1"></a><span class="co">#&gt; 33 104   1       Father Evans   0    NA    NA  103   M</span></span>
<span id="cb10-49"><a href="#cb10-49" tabindex="-1"></a><span class="co">#&gt; 34 103   1       Mother Evans   0    NA    NA  104   F</span></span>
<span id="cb10-50"><a href="#cb10-50" tabindex="-1"></a><span class="co">#&gt; 35 106   1    Father Delacour   0    NA    NA  105   M</span></span>
<span id="cb10-51"><a href="#cb10-51" tabindex="-1"></a><span class="co">#&gt; 36 105   1    Mother Delacour   0    NA    NA  106   F</span></span></code></pre></div>
<p>When the repair argument is set to <code>TRUE</code>, repair process
follows several rules: - Parents listed as mothers must be female -
Parents listed as fathers must be male - Sex codes are standardized to
the specified code_male and code_female values - If no sex code is
provided, the function will attempt to infer what male and female are
coded with. The most frequently assigned sex for mothers and fathers
will be used as the standard.</p>
<p>Note that automatic repairs should be carefully reviewed, as they may
not always reflect the correct biological relationships. In cases where
the sex coding is ambiguous or conflicts with known relationships,
manual inspection and domain knowledge may be required.</p>
<!--
## Practical Example: Cleaning a Pedigree

Below is an example of how to clean and repair a pedigree dataset using the BGmisc package. This example is based on the approach Mason typically takes for data cleaning.


``` r
# note, is broken right now
# Load necessary libraries and datasets
library(tidyverse)
library(BGmisc)
set.seed(123)
# Create a sample dataset similar to the one used in Mason's approach
sample_data <- data.frame(
  ID = 1:10,
  name = c("Person1", "Person2", "Person3", "Person4", "Person5", "Person6", "Person7", "Person8", "Person9", "Person10"),
  dadID = c(NA, NA, 1, 1, 3, 3, 5, 5, 7, 7),
  momID = c(NA, NA, 2, 2, 4, 4, 6, 6, 7, 8),
  sex = c(1, 0, 1, 0, 1, 0, 1, 0, 1, 0),
  byr = runif(10, 1900, 2000),
  dyr = c(NA, NA, NA, NA, NA, NA, NA, NA, NA, NA)
)



summarizePedigrees(sample_data)


# Clean the sample dataset
cleaned_data <- sample_data %>%
  janitor::remove_empty(c("rows", "cols")) %>%
  mutate(
    sex_factor = as.factor(case_when(sex == 1 ~ "male", sex == 0 ~ "female"))
  )

# Check for duplicate IDs
temp_check <- checkIDs(cleaned_data, verbose = TRUE, repair = FALSE)
all_duplicated_ids <- cbind(temp_check$non_unique_ids, temp_check$duplicated_parents_ids)

cleaned_data <- cleaned_data %>%
  mutate(
    duplicated = case_when(ID %in% temp_check$non_unique_ids ~ 1, TRUE ~ 0),
    duplicated_parent = case_when(dadID %in% all_duplicated_ids | momID %in% all_duplicated_ids ~ 1, TRUE ~ 0),
    duplicated_source_ID = case_when(ID %in% all_duplicated_ids ~ ID, dadID %in% all_duplicated_ids ~ dadID, momID %in% all_duplicated_ids ~ momID, TRUE ~ NA_integer_),
    alteredlinks = 0
  )

# Display and manually correct specific errors
cleaned_data %>%
  filter(duplicated == 1 | duplicated_parent == 1) %>%
  arrange(duplicated_source_ID, ID) %>%
  print(n = Inf)

# Perform specific corrections
cleaned_data <- cleaned_data %>%
  mutate(
    alteredlinks = case_when(ID == 9 ~ 1, TRUE ~ alteredlinks),
    ID = case_when(ID == 7 & round(byr, digits = 0) == 2020 ~ ID + 1e6, TRUE ~ ID)
  )

# Final check for remaining duplicates
final_check <- checkIDs(cleaned_data, verbose = TRUE, repair = FALSE)
print(final_check)
```
-->
</div>
<div id="best-practices-for-pedigree-validation" class="section level1">
<h1>Best Practices for Pedigree Validation</h1>
<p>Through extensive work with pedigree data, we’ve learned several key
principles:</p>
<ul>
<li>Always inspect your data before applying automatic repairs</li>
<li>Use summarizeFamilies() to get an overview of family structures</li>
<li>Keep detailed records of changes made during cleaning</li>
<li>Validate after each repair step</li>
<li>Create backups before applying repairs</li>
<li>Trust your domain knowledge - automatic repairs are helpful but not
infallible</li>
</ul>
<p>By following these best practices, and leveraging functions like
<code>checkIDs</code>, <code>checkSex</code>, and
<code>recodeSex</code>, you can ensure the integrity of your pedigree
data, facilitating accurate analysis and research.</p>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>

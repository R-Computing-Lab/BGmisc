---
title: "Validation tools for identifying and repairing errors in pedigrees"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Validation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
options(rmarkdown.html_vignette.check_title = FALSE)
```

# Introduction

The `BGmisc` R package offers a comprehensive suite of functions tailored for extended behavior genetics analysis, including model identification, calculating relatedness, pedigree conversion, and pedigree simulation. This vignette provides an overview of the validation tools available in the package, designed to identify and repair errors in pedigrees. 

In an ideal world, you would have perfect pedigrees with no errors. However, in the real world, pedigrees are often incomplete, contain errors, or are missing data. The `BGmisc` package provides tools to identify these errors, which is particularly useful for large pedigrees where manual inspection is not feasible. 
While some errors in the package can be automatically repaired, the vast majority require manual inspection. It is often not possible to automatically repair errors in pedigrees, as the correct solution may not be obvious, or may depend on additional information that is not universally available.

# Identifying and Repairing Errors in Pedigrees

## ID Validation

One common issue in pedigree data is the presence of duplicate IDs. There are two main types of ID duplication: within-row duplication and across-row duplication. Within-row duplication occurs when an individual's parents' IDs are incorrectly listed as their own ID. Across-row duplication occurs when two or more individuals share the same ID.

 The `checkIDs` function in BGmisc helps identify by kinds of duplicates. Here's how to use it:

```{r,checkIDs}
# Create a sample dataset
df <- ped2fam(potter, famID = "newFamID", personID = "personID")

# Call the checkIDs function
result <- checkIDs(df, repair = FALSE)
print(result)

#> $all_unique_ids
#> [1] TRUE
#> 
#> $total_non_unique_ids
#> [1] 0
#> 
#> $total_own_father
#> [1] 0
#> 
#> $total_own_mother
#> [1] 0
#> 
#> $total_duplicated_parents
#> [1] 0
#> 
#> $total_within_row_duplicates
#> [1] 0
#> 
#> $within_row_duplicates
#> [1] FALSE
```

In this example, the `checkIDs` function returns a list with several elements. The `all_unique_ids` element indicates whether all IDs in the dataset are unique. The `total_non_unique_ids` element indicates the total number of non-unique IDs. The `total_own_father` and `total_own_mother` elements indicate the total number of individuals whose father's and mother's IDs match their own ID, respectively. The `total_duplicated_parents` element indicates the total number of individuals with duplicated parent IDs. The `total_within_row_duplicates` element indicates the total number of within-row duplicates. The `within_row_duplicates` element indicates whether there are any within-row duplicates in the dataset. As the output shows, there are no duplicates in the sample dataset. 


### Between-Person Duplicates

Let us now consider a scenario where there are between-person duplicates in the dataset. The `checkIDs` function can identify these duplicates and, if the `repair` argument is set to `TRUE`, attempt to repair them. In the example below, we have created two between-person duplicates. First, we have overwritten the `personID` of one person with their sibling's ID. Second, we have added a copy of Dudley Dursley to the dataset.



```{r, repair}
# Create a sample dataset with duplicates
df <- ped2fam(potter, famID = "newFamID", personID = "personID")

# Sibling overwrite
df$personID[df$name == "Vernon Dursley"] <- df$personID[df$name == "Marjorie Dursley"]

# Add a copy of Dudley Dursley
df <- rbind(df, df[df$name == "Dudley Dursley",])
```

Now, let's call the `sumarizeFamilies` function to see what the dataset looks like.

```{r}
library(tidyverse)

summarizeFamilies(df, famID = "newFamID", personID = "personID")$family_summary %>% glimpse()
```
If we didn't know to look for duplicates, we might not notice the issue. Indeed, only of the duplicates was selected as are founder member. However, the `checkIDs` function can help us identify and repair these errors:

```{r}
# Call the checkIDs
result <- checkIDs(df)

print(result)
```

As we can see from this output, there are `r result$total_non_unique_ids` non-unique IDs in the dataset, specifically `r result$non_unique_ids`. Let's take a peek at the duplicates:

```{r}
library(tidyverse)

df %>% filter(personID %in% result$non_unique_ids) %>%
  arrange(personID)  %>% print(n=Inf)

```
Yep, these are  definitely the duplicates.

```{r}
df_repair <- checkIDs(df, repair = TRUE)

df_repair %>% filter(ID %in% result$non_unique_ids) %>%
  arrange(ID)  %>% print(n=Inf)

result <- checkIDs(df_repair)

print(result)
```

Great! The function was able to repair the full duplicate, without any manual intervention. That still leaves us with the sibling overwrite, but that's a more complex issue that would require manual intervention. We'll leave that for now.


### Handling Within-Row Duplicates

Sometimes, an individual's parents' IDs may be incorrectly listed as their own ID, leading to within-row duplicates. The checkIDs function can also identify these errors:

```{r within}
# Create a sample dataset with within-person duplicate parent IDs

df <- ped2fam(potter, famID = "newFamID", personID = "personID")

df$momID[df$name == "Vernon Dursley"] <- df$personID[df$name == "Vernon Dursley"]

# Check for within-row duplicates
result <- checkIDs(df, repair = FALSE)
print(result)
```

In this example, we have created a within-row duplicate by setting the momID of Vernon Dursley to his own ID. The `checkIDs` function correctly identifies this error. 

